import asyncio
import json
import os
import random
import time
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from aiogram.utils.keyboard import ReplyKeyboardBuilder
from aiogram.utils.markdown import hbold, hitalic, hunderline
from flask import Flask
import threading

API_TOKEN = '7537085884:AAGuseMdxP0Uwlhhv4Ltgg3-hmo0EJYkAG4'
bot = Bot(token=API_TOKEN)
dp = Dispatcher()
DATA_FILE = "balances.json"
ADMINS = ["729406890"]
users = {}
STARTING_BALANCE = 1000
jackpot = 5000
casino_balance = 0
current_game = {}
duels = {}
awaiting_nickname = {}
last_action_time = {}
SPAM_COOLDOWN = 2
TELEGRAM_CHANNEL = "https://t.me/your_channel_name"
REFERRAL_BONUS = 50000
MAINTENANCE_MODE = False

def load_data():
    global users, jackpot, casino_balance
    if os.path.exists(DATA_FILE):
        with open(DATA_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
            users = data.get("users", {})
            jackpot = data.get("jackpot", 5000)
            casino_balance = data.get("casino_balance", 0)
            for user_id, user_data in users.items():
                if "nickname" not in user_data: user_data["nickname"] = user_data["username"]
                if "last_daily_bonus" not in user_data: user_data["last_daily_bonus"] = 0.0
                if "subscribed" not in user_data: user_data["subscribed"] = False
                if "invited_by" not in user_data: user_data["invited_by"] = None
                if "hide_in_leaderboard" not in user_data: user_data["hide_in_leaderboard"] = False
    else:
        users = {}
        jackpot = 5000
        casino_balance = 0

def save_data():
    with open(DATA_FILE, "w", encoding="utf-8") as f:
        json.dump({"users": users, "jackpot": jackpot, "casino_balance": casino_balance}, f, ensure_ascii=False, indent=4)

def check_spam(user_id):
    current_time = time.time()
    last_time = last_action_time.get(user_id, 0)
    if current_time - last_time < SPAM_COOLDOWN: return False
    last_action_time[user_id] = current_time
    return True

def check_and_add_daily_bonus(user_id):
    current_time = time.time()
    last_bonus = users[user_id].get("last_daily_bonus", 0.0)
    if current_time - last_bonus >= 86400:
        users[user_id]["balance"] += 1000
        users[user_id]["last_daily_bonus"] = current_time
        save_data()
        return True
    return False

def get_referral_link(user_id):
    return f"t.me/{bot._me.username}?start=ref_{user_id}"

async def process_referral(referrer_id, new_user_id):
    if referrer_id == new_user_id: return
    if referrer_id in users and users[referrer_id].get("balance") is not None:
        users[referrer_id]["balance"] += REFERRAL_BONUS
        save_data()
        await bot.send_message(referrer_id, f"{hbold('–ù–û–í–´–ô –†–ï–§–ï–†–ê–õ!')}\n\n–í—ã –ø—Ä–∏–≥–ª–∞—Å–∏–ª–∏ –¥—Ä—É–≥–∞ –∏ –ø–æ–ª—É—á–∏–ª–∏ {hbold(f'{REFERRAL_BONUS} üí∞')}\n–í–∞—à –±–∞–ª–∞–Ω—Å: {hbold(str(users[referrer_id]['balance']) + ' üí∞')}", parse_mode="HTML")

def get_combo_text(dice_value: int):
    values = ["BAR", "üçá", "üçã", "7"]
    dice_value -= 1
    result = []
    for _ in range(3):
        result.append(values[dice_value % 4])
        dice_value //= 4
    return result

def determine_slot_win(dice_value, bet, user_id):
    global jackpot, casino_balance
    winnings = 0
    combo = get_combo_text(dice_value)
    message = f"–ö–æ–º–±–∏–Ω–∞—Ü–∏—è: {combo[0]} {combo[1]} {combo[2]}\n"
    freespins = users[user_id].get("freespins", 0)
    if combo == ["7", "7", "7"]: winnings, freespins, message = bet * 10, freespins + 3, message + f"{hbold('–¢–†–ò –°–ï–ú–Å–†–ö–ò!')}\n{hunderline('+3 —Ñ—Ä–∏—Å–ø–∏–Ω–∞')}"
    elif combo == ["üçã", "üçã", "üçã"]: winnings, message = bet * 5 * (2 if freespins > 0 else 1), message + f"{hbold('–í–´–ò–ì–†–´–®!')} {hitalic('–¢—Ä–∏ –ª–∏–º–æ–Ω–∞')}"
    elif combo == ["BAR", "BAR", "BAR"]: winnings, message = bet * 8, message + f"{hbold('–í–´–ò–ì–†–´–®!')} {hitalic('–¢—Ä–∏ BAR')}"
    elif combo == ["üçá", "üçá", "üçá"]: winnings, message = bet * 6, message + f"{hbold('–í–´–ò–ì–†–´–®!')} {hitalic('–¢—Ä–∏ –≤–∏–Ω–æ–≥—Ä–∞–¥–∞')}"
    elif combo[0] == "7" and combo[1] == "7": winnings, message = bet * 5, message + f"{hbold('–í–´–ò–ì–†–´–®!')} {hitalic('–î–≤–µ —Å–µ–º—ë—Ä–∫–∏ –≤ –Ω–∞—á–∞–ª–µ')}"
    else: message += "–£–≤—ã, –Ω–µ—Ç –≤—ã–∏–≥—Ä—ã—à–∞ üòî"
    if random.random() < 0.05:
        bonus = random.randint(1, 3)
        if bonus <= 2: winnings, message = winnings + bonus * bet, message + f"\n{hbold('–°–õ–£–ß–ê–ô–ù–´–ô –ë–û–ù–£–°:')} {hitalic(f'+{bonus * bet} üí∞')}"
        else: freespins, message = freespins + 1, message + f"\n{hbold('–°–õ–£–ß–ê–ô–ù–´–ô –ë–û–ù–£–°:')} {hunderline('+1 —Ñ—Ä–∏—Å–ø–∏–Ω')}"
    users[user_id]["freespins"] = freespins
    return winnings, message, "gamble" if winnings > 0 and random.random() < 0.5 else None

def determine_dice_win(value, bet):
    if value == 6: return bet * 3, f"{hbold('–®–ï–°–¢–Å–†–ö–ê!')}\n{hitalic('–û—Ç–ª–∏—á–Ω—ã–π –±—Ä–æ—Å–æ–∫')}"
    elif value == 5: return bet * 2, f"{hbold('–•–û–†–û–®–ò–ô –ë–†–û–°–û–ö!')}\n{hitalic('–ù–µ–ø–ª–æ—Ö–æ')}"
    return 0, "–£–≤—ã, –Ω–µ—Ç –≤—ã–∏–≥—Ä—ã—à–∞ üòî"

def determine_darts_win(value, bet):
    if value == 6: return bet * 5, f"{hbold('–í –Ø–ë–õ–û–ß–ö–û!')}\n{hitalic('–û—Ç–ª–∏—á–Ω—ã–π –±—Ä–æ—Å–æ–∫')}"
    return 0, "–ú–∏–º–æ üòî"

def determine_basketball_win(value, bet):
    if value in [4, 5]: return bet * 3, f"{hbold('–í –ö–û–õ–¨–¶–û!')}\n{hitalic('–ö–ª–∞—Å—Å–Ω—ã–π –±—Ä–æ—Å–æ–∫')}"
    return 0, "–ú–∏–º–æ üòî"

def determine_football_win(value, bet):
    if value in [3, 4, 5]: return bet * 3, f"{hbold('–ì–û–õ!')}\n{hitalic('–û—Ç–ª–∏—á–Ω—ã–π —É–¥–∞—Ä')}"
    return 0, "–ú–∏–º–æ –≤–æ—Ä–æ—Ç üòî"

def determine_bowling_win(value, bet):
    if value == 6: return bet * 5, f"{hbold('–°–¢–†–ê–ô–ö!')}\n{hitalic('–ò–¥–µ–∞–ª—å–Ω—ã–π –±—Ä–æ—Å–æ–∫')}"
    return 0, "–ü—Ä–æ–º–∞—Ö üòî"

def get_casino_menu():
    builder = ReplyKeyboardBuilder()
    builder.button(text="–ò–≥—Ä—ã üéÆ"); builder.button(text="–ê–∫–∫–∞—É–Ω—Ç üë§")
    builder.button(text="–ú–Ω–æ–≥–æ–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ –∫–∞–∑–∏–Ω–æ üë•"); builder.button(text="–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤ üèÜ")
    builder.button(text="–¢—É—Ä–Ω–∏—Ä—ã üèÖ")
    builder.adjust(2)
    return builder.as_markup(resize_keyboard=True)

def get_game_menu():
    builder = ReplyKeyboardBuilder()
    builder.button(text="–°–ª–æ—Ç—ã üé∞"); builder.button(text="–ö—É–±–∏–∫–∏ üé≤")
    builder.button(text="–ë–∞—Å–∫–µ—Ç–±–æ–ª üèÄ"); builder.button(text="–ë–æ—É–ª–∏–Ω–≥ üé≥")
    builder.button(text="–§—É—Ç–±–æ–ª ‚öΩ"); builder.button(text="–î–∞—Ä—Ç—Å üéØ")
    builder.button(text="–ù–∞–∑–∞–¥ –≤ –∫–∞–∑–∏–Ω–æ")
    builder.adjust(2)
    return builder.as_markup(resize_keyboard=True)

def get_bet_keyboard():
    builder = ReplyKeyboardBuilder()
    builder.button(text="10 üí∞"); builder.button(text="100 üí∞")
    builder.button(text="1000 üí∞"); builder.button(text="–û–ª–ª-–∏–Ω üí∞")
    builder.button(text="–°–≤–æ—è —Å—Ç–∞–≤–∫–∞"); builder.button(text="–ë–∞–ª–∞–Ω—Å")
    builder.button(text="–ü—Ä–∞–≤–∏–ª–∞ üìú"); builder.button(text="–ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é")
    builder.adjust(2)
    return builder.as_markup(resize_keyboard=True)

def get_account_menu():
    builder = ReplyKeyboardBuilder()
    builder.button(text="–ë–æ–Ω—É—Å—ã üéÅ"); builder.button(text="–ü–µ—Ä–µ–¥–∞—Ç—å –¥–µ–Ω—å–≥–∏ üí∏")
    builder.button(text="–ò–º—è ‚úèÔ∏è"); builder.button(text="–ù–∞–∑–∞–¥ –≤ –∫–∞–∑–∏–Ω–æ")
    builder.adjust(2)
    return builder.as_markup(resize_keyboard=True)

def get_bonus_menu():
    builder = ReplyKeyboardBuilder()
    builder.button(text="–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª (+500 üí∞)")
    builder.button(text="–ü—Ä–∏–≥–ª–∞—Å–∏ –¥—Ä—É–≥–∞ üë§")
    builder.button(text="–ù–∞–∑–∞–¥ –≤ –∞–∫–∫–∞—É–Ω—Ç")
    builder.adjust(1)
    return builder.as_markup(resize_keyboard=True)

def get_name_menu():
    builder = ReplyKeyboardBuilder()
    builder.button(text="–°–º–µ–Ω–∏—Ç—å –Ω–∏–∫–Ω–µ–π–º")
    builder.button(text="–°–∫—Ä—ã—Ç—å/–ü–æ–∫–∞–∑–∞—Ç—å –≤ —Ç–∞–±–ª–∏—Ü–µ –ª–∏–¥–µ—Ä–æ–≤")
    builder.button(text="–ù–∞–∑–∞–¥ –≤ –∞–∫–∫–∞—É–Ω—Ç")
    builder.adjust(1)
    return builder.as_markup(resize_keyboard=True)

def get_multiplayer_menu():
    builder = ReplyKeyboardBuilder()
    builder.button(text="–î—É—ç–ª—å ‚öîÔ∏è"); builder.button(text="–ö–æ–º–Ω–∞—Ç—ã üè†")
    builder.button(text="–ù–∞–∑–∞–¥ –≤ –∫–∞–∑–∏–Ω–æ")
    builder.adjust(2)
    return builder.as_markup(resize_keyboard=True)

def get_duel_game_menu():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–ö—É–±–∏–∫–∏ üé≤", callback_data="duel_game_dice"), InlineKeyboardButton(text="–ë–∞—Å–∫–µ—Ç–±–æ–ª üèÄ", callback_data="duel_game_basketball")],
        [InlineKeyboardButton(text="–ë–æ—É–ª–∏–Ω–≥ üé≥", callback_data="duel_game_bowling"), InlineKeyboardButton(text="–§—É—Ç–±–æ–ª ‚öΩ", callback_data="duel_game_football")],
        [InlineKeyboardButton(text="–î–∞—Ä—Ç—Å üéØ", callback_data="duel_game_darts")]
    ])

async def send_rules(message: Message):
    rules = f"{hbold('–ü–†–ê–í–ò–õ–ê –ò–ì–†–´')}\n\n{hunderline('–°–õ–û–¢–´')}\n–°–∏–º–≤–æ–ª—ã: 7 BAR üçã üçá\n{hbold('–ö–û–ú–ë–ò–ù–ê–¶–ò–ò:')}\n    –¢—Ä–∏ üçã: {hitalic('x5 —Å—Ç–∞–≤–∫–∏ (x2 –≤–æ —Ñ—Ä–∏—Å–ø–∏–Ω–∞—Ö)')}\n    –¢—Ä–∏ BAR: {hitalic('x8 —Å—Ç–∞–≤–∫–∏')}\n    –¢—Ä–∏ üçá: {hitalic('x6 —Å—Ç–∞–≤–∫–∏')}\n    –î–≤–µ 7 –≤ –Ω–∞—á–∞–ª–µ: {hitalic('x5 —Å—Ç–∞–≤–∫–∏')}\n    –¢—Ä–∏ 7: {hitalic('x10 —Å—Ç–∞–≤–∫–∏, +3 —Ñ—Ä–∏—Å–ø–∏–Ω–∞')}\n{hbold('–°–õ–£–ß–ê–ô–ù–´–ô –ë–û–ù–£–°:')} {hitalic('5% —à–∞–Ω—Å –Ω–∞ +1-3x —Å—Ç–∞–≤–∫–∏ üí∞ –∏–ª–∏ +1 —Ñ—Ä–∏—Å–ø–∏–Ω')}\n{hbold('–†–ò–°–ö-–ò–ì–†–ê:')} {hitalic('50% —à–∞–Ω—Å —É–¥–≤–æ–∏—Ç—å –≤—ã–∏–≥—Ä—ã—à (‚ù§Ô∏è –∏–ª–∏ ‚ô†Ô∏è)')}\n\n–ö–£–ë–ò–ö–ò: {hitalic('6 ‚Äî x3, 5 ‚Äî x2')}\n–î–ê–†–¢–°: {hitalic('6 ‚Äî x5')}\n–ë–ê–°–ö–ï–¢–ë–û–õ: {hitalic('4 –∏–ª–∏ 5 ‚Äî x3')}\n–§–£–¢–ë–û–õ: {hitalic('3, 4 –∏–ª–∏ 5 ‚Äî x3')}\n–ë–û–£–õ–ò–ù–ì: {hitalic('6 ‚Äî x5')}\n\n{hitalic('–ò—Å–ø–æ–ª—å–∑—É–π /rules –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞!')}"
    await message.reply(rules, parse_mode="HTML")

@dp.message(Command(commands=["start"]))
async def start_command(message: Message):
    if MAINTENANCE_MODE: return await message.reply(f"{hbold('–¢–ï–•–ù–ò–ß–ï–°–ö–ò–ï –†–ê–ë–û–¢–´')}\n\n–ë–æ—Ç –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.", parse_mode="HTML")
    user_id = str(message.from_user.id)
    username = message.from_user.username or "NoUsername"
    args = message.text.split()
    referrer_id = args[1].replace("ref_", "") if len(args) > 1 and args[1].startswith("ref_") else None
    if user_id not in users:
        users[user_id] = {"balance": STARTING_BALANCE, "username": username, "freespins": 0, "multiplier": 1.0, "last_daily_bonus": 0.0, "subscribed": False, "invited_by": referrer_id, "hide_in_leaderboard": False}
        awaiting_nickname[user_id] = True
        await message.reply(f"{hbold('–î–û–ë–†–û –ü–û–ñ–ê–õ–û–í–ê–¢–¨!')}\n\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ —Å–≤–æ–π –Ω–∏–∫–Ω–µ–π–º:", parse_mode="HTML")
        if referrer_id: await process_referral(referrer_id, user_id)
    else:
        bonus = check_and_add_daily_bonus(user_id)
        await message.reply(f"{hbold('–ï–ñ–ï–î–ù–ï–í–ù–´–ô –ë–û–ù–£–°!')}\n\n–í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ {hbold('1000 üí∞')}\n–ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {hbold(str(users[user_id]['balance']) + ' üí∞')}\n\n{hbold('–í–´–ë–ï–†–ò –†–ê–ó–î–ï–õ:')}" if bonus else f"{hbold('–í–´–ë–ï–†–ò –†–ê–ó–î–ï–õ:')}\n", reply_markup=get_casino_menu(), parse_mode="HTML")

@dp.message(lambda message: str(message.from_user.id) in awaiting_nickname and not MAINTENANCE_MODE)
async def set_nickname(message: Message):
    user_id = str(message.from_user.id)
    nickname = message.text.strip()
    if len(nickname) > 20: return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –ù–∏–∫–Ω–µ–π–º —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å–∏–º—É–º 20 —Å–∏–º–≤–æ–ª–æ–≤)!", parse_mode="HTML")
    users[user_id]["nickname"] = nickname
    del awaiting_nickname[user_id]
    save_data()
    await message.reply(f"{hbold('–ù–∏–∫–Ω–µ–π–º —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω:')} {nickname}\n\n{hbold('–í–´–ë–ï–†–ò –†–ê–ó–î–ï–õ:')}\n", reply_markup=get_casino_menu(), parse_mode="HTML")

@dp.message(Command(commands=["rules"]))
async def rules_command(message: Message):
    if MAINTENANCE_MODE: return await message.reply(f"{hbold('–¢–ï–•–ù–ò–ß–ï–°–ö–ò–ï –†–ê–ë–û–¢–´')}\n\n–ë–æ—Ç –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.", parse_mode="HTML")
    await send_rules(message)

@dp.message(Command(commands=["addcoins"]))
async def add_coins(message: Message):
    if MAINTENANCE_MODE: return await message.reply(f"{hbold('–¢–ï–•–ù–ò–ß–ï–°–ö–ò–ï –†–ê–ë–û–¢–´')}\n\n–ë–æ—Ç –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.", parse_mode="HTML")
    user_id = str(message.from_user.id)
    if user_id not in ADMINS: return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É –∫–æ–º–∞–Ω–¥—É!", parse_mode="HTML")
    args = message.text.split()
    if len(args) != 3 or not args[2].isdigit(): return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –ò—Å–ø–æ–ª—å–∑—É–π: /addcoins <username> <amount>", parse_mode="HTML")
    target_username, amount = args[1].lstrip('@'), int(args[2])
    if amount <= 0: return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å {hunderline('–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π')}", parse_mode="HTML")
    target_user_id = next((uid for uid, data in users.items() if data["username"].lower() == target_username.lower()), None)
    if not target_user_id: return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å @{target_username} –Ω–µ –Ω–∞–π–¥–µ–Ω", parse_mode="HTML")
    users[target_user_id]["balance"] += amount
    save_data()
    await message.reply(f"{hbold('–£—Å–ø–µ—Ö!')} –î–æ–±–∞–≤–ª–µ–Ω–æ {hbold(str(amount) + ' üí∞')} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é @{target_username}\n–ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {hbold(str(users[target_user_id]['balance']) + ' üí∞')}", parse_mode="HTML")

async def offer_gamble(user_id, chat_id, winnings):
    keyboard = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="‚ù§Ô∏è", callback_data=f"gamble_{user_id}_red_{winnings}"), InlineKeyboardButton(text="‚ô†Ô∏è", callback_data=f"gamble_{user_id}_black_{winnings}")]])
    await bot.send_message(chat_id, f"{hbold('–£–î–í–û–ò–¢–¨ –í–´–ò–ì–†–´–®?')}\n\n–°–µ–π—á–∞—Å: {hbold(str(winnings) + ' üí∞')}\n\n{hitalic('–í—ã–±–µ—Ä–∏ —Ü–≤–µ—Ç:')}", reply_markup=keyboard, parse_mode="HTML")

@dp.callback_query()
async def process_callback(callback: CallbackQuery):
    if MAINTENANCE_MODE: return await callback.message.edit_text(f"{hbold('–¢–ï–•–ù–ò–ß–ï–°–ö–ò–ï –†–ê–ë–û–¢–´')}\n\n–ë–æ—Ç –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.", parse_mode="HTML")
    global casino_balance
    user_id = str(callback.from_user.id)
    data = callback.data.split("_")
    if data[0] == "gamble":
        color, winnings = data[2], int(data[3])
        correct_color = random.choice(["red", "black"])
        message = f"{hbold('–£–ì–ê–î–ê–õ!')}\n–í—ã–∏–≥—Ä—ã—à —É–¥–≤–æ–µ–Ω: {hbold(str(winnings * 2) + ' üí∞')}" if color == correct_color else f"{hbold('–ù–ï –£–ì–ê–î–ê–õ!')}\n–í—ã–∏–≥—Ä—ã—à {winnings} üí∞ –ø–æ—Ç–µ—Ä—è–Ω üòî"
        if color == correct_color: users[user_id]["balance"] += winnings; casino_balance -= winnings
        else: casino_balance += winnings
        save_data()
        await callback.message.edit_text(f"{message}\n\n–ë–∞–ª–∞–Ω—Å: {hbold(str(users[user_id]['balance']) + ' üí∞')}", parse_mode="HTML")
    elif data[0] == "check" and data[1] == "sub":
        user_id = data[2]
        if not users[user_id]["subscribed"]:
            users[user_id]["balance"] += 500; users[user_id]["subscribed"] = True; save_data()
            await callback.message.edit_text(f"{hbold('–°–ü–ê–°–ò–ë–û –ó–ê –ü–û–î–ü–ò–°–ö–£!')}\n\n–í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ {hbold('500 üí∞')}\n–ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {hbold(str(users[user_id]['balance']) + ' üí∞')}", parse_mode="HTML")
        else:
            await callback.message.edit_text(f"{hbold('–í—ã —É–∂–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã!')}\n\n–ë–æ–Ω—É—Å –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É —É–∂–µ –ø–æ–ª—É—á–µ–Ω.", parse_mode="HTML")
    elif data[0] == "show" and data[1] == "full" and data[2] == "leaderboard":
        if not users: return await callback.message.edit_text(f"{hbold('–¢–ê–ë–õ–ò–¶–ê –õ–ò–î–ï–†–û–í')}\n\n–ü–æ–∫–∞ –Ω–µ—Ç –∏–≥—Ä–æ–∫–æ–≤ üòî", parse_mode="HTML")
        leaderboard = sorted([(uid, data) for uid, data in users.items() if not data.get("hide_in_leaderboard", False)], key=lambda x: x[1]["balance"], reverse=True)
        response = f"{hbold('–ü–û–õ–ù–ê–Ø –¢–ê–ë–õ–ò–¶–ê –õ–ò–î–ï–†–û–í')}\n\n" + "".join(f"  {i}. {data.get('nickname', data['username'])} (@{data['username']}): {hbold(str(data['balance']) + ' üí∞')}\n" if user_id in ADMINS else f"  {i}. {data.get('nickname', data['username'])}: {hbold(str(data['balance']) + ' üí∞')}\n" for i, (uid, data) in enumerate(leaderboard, 1)) + f"\n{hunderline('–°–ß–Å–¢ –ö–ê–ó–ò–ù–û:')} {hbold(str(casino_balance) + ' üí∞')}"
        await callback.message.edit_text(response, parse_mode="HTML")
    elif data[0] == "duel" and data[1] == "game":
        game = data[2]
        current_game[user_id] = {"mode": "duel", "game": game}
        await callback.message.edit_text(f"{hbold('–î–£–≠–õ–¨')}\n\n–ò–≥—Ä–∞ –≤—ã–±—Ä–∞–Ω–∞: {game.capitalize()}\n–£–∫–∞–∂–∏—Ç–µ —Å—É–º–º—É —Å—Ç–∞–≤–∫–∏ (—á–∏—Å–ª–æ):", parse_mode="HTML")
    elif data[0] == "duel" and data[1] == "accept":
        duel_id = "_".join(data[2:])
        if duel_id not in duels: return await callback.message.edit_text(f"{hbold('–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ!')}\n\n–î—É—ç–ª—å –±–æ–ª—å—à–µ –Ω–µ –∞–∫—Ç—É–∞–ª—å–Ω–∞.", parse_mode="HTML")
        challenger_id, opponent_id, game, bet = duels[duel_id]["challenger"], user_id, duels[duel_id]["game"], duels[duel_id]["bet"]
        if users[opponent_id]["balance"] < bet:
            await callback.message.edit_text(f"{hbold('–û—à–∏–±–∫–∞!')}\n\n–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –ø—Ä–∏–Ω—è—Ç–∏—è –¥—É—ç–ª–∏!", parse_mode="HTML")
            await bot.send_message(challenger_id, f"{hbold('–î—É—ç–ª—å –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞!')}\n\n–£ @{users[opponent_id]['username']} –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤.", parse_mode="HTML")
            del duels[duel_id]
            return
        users[challenger_id]["balance"] -= bet; users[opponent_id]["balance"] -= bet; save_data()
        game_names = {"dice": "–ö—É–±–∏–∫–∏ üé≤", "basketball": "–ë–∞—Å–∫–µ—Ç–±–æ–ª üèÄ", "bowling": "–ë–æ—É–ª–∏–Ω–≥ üé≥", "football": "–§—É—Ç–±–æ–ª ‚öΩ", "darts": "–î–∞—Ä—Ç—Å üéØ"}
        duels[duel_id]["state"] = "rolling_order"; duels[duel_id]["challenger_roll"] = None; duels[duel_id]["opponent_roll"] = None
        await callback.message.edit_text(f"{hbold('–î—É—ç–ª—å –ø—Ä–∏–Ω—è—Ç–∞!')}\n\n–ë—Ä–æ—Å—å—Ç–µ –∫—É–±–∏–∫–∏, —á—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ—Ä—è–¥–æ–∫ —Ö–æ–¥–∞.", reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="–ë—Ä–æ—Å–∏—Ç—å –∫—É–±–∏–∫–∏", callback_data=f"duel_roll_{duel_id}_{opponent_id}")]]), parse_mode="HTML")
        await bot.send_message(challenger_id, f"{hbold('–î—É—ç–ª—å –ø—Ä–∏–Ω—è—Ç–∞!')}\n\n–ò–≥—Ä–∞: {game_names[game]}\n–°—Ç–∞–≤–∫–∞: {bet} üí∞\n–ë—Ä–æ—Å—å—Ç–µ –∫—É–±–∏–∫–∏, —á—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ—Ä—è–¥–æ–∫ —Ö–æ–¥–∞.", reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="–ë—Ä–æ—Å–∏—Ç—å –∫—É–±–∏–∫–∏", callback_data=f"duel_roll_{duel_id}_{challenger_id}")]]), parse_mode="HTML")
    elif data[0] == "duel" and data[1] == "decline":
        duel_id = "_".join(data[2:])
        if duel_id not in duels: return await callback.message.edit_text(f"{hbold('–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ!')}\n\n–î—É—ç–ª—å –±–æ–ª—å—à–µ –Ω–µ –∞–∫—Ç—É–∞–ª—å–Ω–∞.", parse_mode="HTML")
        challenger_id = duels[duel_id]["challenger"]
        await callback.message.edit_text(f"{hbold('–î—É—ç–ª—å –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞!')}\n\n–í—ã –æ—Ç–∫–∞–∑–∞–ª–∏—Å—å –æ—Ç –¥—É—ç–ª–∏ —Å @{users[challenger_id]['username']}.", parse_mode="HTML")
        await bot.send_message(challenger_id, f"{hbold('–î—É—ç–ª—å –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞!')}\n\n@{users[user_id]['username']} –æ—Ç–∫–∞–∑–∞–ª—Å—è –æ—Ç –≤–∞—à–µ–π –¥—É—ç–ª–∏.", parse_mode="HTML")
        del duels[duel_id]
    elif data[0] == "duel" and data[1] == "roll":
        duel_id, player_id = "_".join(data[2:-1]), data[-1]
        if duel_id not in duels or duels[duel_id]["state"] != "rolling_order": return await callback.message.edit_text(f"{hbold('–û—à–∏–±–∫–∞!')}\n\n–î—É—ç–ª—å –Ω–µ –≤ —Å—Ç–∞–¥–∏–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ—Ä—è–¥–∫–∞ –∏–ª–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.", parse_mode="HTML")
        challenger_id, opponent_id = duels[duel_id]["challenger"], duels[duel_id]["opponent"]
        other_player_id = opponent_id if player_id == challenger_id else challenger_id
        if (player_id == challenger_id and duels[duel_id]["challenger_roll"]) or (player_id == opponent_id and duels[duel_id]["opponent_roll"]): return await callback.message.edit_text(f"{hbold('–û—à–∏–±–∫–∞!')}\n\n–í—ã —É–∂–µ –±—Ä–æ—Å–∏–ª–∏ –∫—É–±–∏–∫–∏ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ—Ä—è–¥–∫–∞ —Ö–æ–¥–∞!", parse_mode="HTML")
        dice = await bot.send_dice(callback.message.chat.id, emoji="üé≤"); await asyncio.sleep(4); dice_value = dice.dice.value
        if player_id == challenger_id: duels[duel_id]["challenger_roll"] = dice_value
        else: duels[duel_id]["opponent_roll"] = dice_value
        await callback.message.edit_text(f"{hbold('–í—ã –±—Ä–æ—Å–∏–ª–∏ –∫—É–±–∏–∫–∏!')}\n\n–í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {dice_value}", parse_mode="HTML")
        await bot.send_message(other_player_id, f"{hbold('–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫ –±—Ä–æ—Å–∏–ª –∫—É–±–∏–∫–∏!')}\n\n@{users[player_id]['username']} –≤—ã–±—Ä–æ—Å–∏–ª: {dice_value}", parse_mode="HTML")
        if duels[duel_id]["challenger_roll"] and duels[duel_id]["opponent_roll"]:
            challenger_value, opponent_value = duels[duel_id]["challenger_roll"], duels[duel_id]["opponent_roll"]
            first_player, second_player = (challenger_id, opponent_id) if challenger_value >= opponent_value else (opponent_id, challenger_id)
            duels[duel_id]["state"] = "playing"; duels[duel_id]["first_player"] = first_player; duels[duel_id]["second_player"] = second_player; duels[duel_id]["current_turn"] = first_player
            game_names = {"dice": "–ö—É–±–∏–∫–∏ üé≤", "basketball": "–ë–∞—Å–∫–µ—Ç–±–æ–ª üèÄ", "bowling": "–ë–æ—É–ª–∏–Ω–≥ üé≥", "football": "–§—É—Ç–±–æ–ª ‚öΩ", "darts": "–î–∞—Ä—Ç—Å üéØ"}
            game, bet = duels[duel_id]["game"], duels[duel_id]["bet"]
            await bot.send_message(challenger_id, f"{hbold('–î—É—ç–ª—å –Ω–∞—á–∞–ª–∞—Å—å!')}\n\n–ò–≥—Ä–∞: {game_names[game]}\n–°—Ç–∞–≤–∫–∞: {bet} üí∞\n–ü–µ—Ä–≤—ã–π —Ö–æ–¥: @{users[first_player]['username']}\n–í–∞—à –∫—É–±–∏–∫: {challenger_value}, —Å–æ–ø–µ—Ä–Ω–∏–∫: {opponent_value}", reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="–°–¥–µ–ª–∞—Ç—å —Ö–æ–¥", callback_data=f"duel_turn_{duel_id}_{challenger_id}")]]) if first_player == challenger_id else None, parse_mode="HTML")
            await bot.send_message(opponent_id, f"{hbold('–î—É—ç–ª—å –Ω–∞—á–∞–ª–∞—Å—å!')}\n\n–ò–≥—Ä–∞: {game_names[game]}\n–°—Ç–∞–≤–∫–∞: {bet} üí∞\n–ü–µ—Ä–≤—ã–π —Ö–æ–¥: @{users[first_player]['username']}\n–í–∞—à –∫—É–±–∏–∫: {opponent_value}, —Å–æ–ø–µ—Ä–Ω–∏–∫: {challenger_value}", reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="–°–¥–µ–ª–∞—Ç—å —Ö–æ–¥", callback_data=f"duel_turn_{duel_id}_{opponent_id}")]]) if first_player == opponent_id else None, parse_mode="HTML")
    elif data[0] == "duel" and data[1] == "turn":
        duel_id, player_id = "_".join(data[2:-1]), data[-1]
        if duel_id not in duels or duels[duel_id]["state"] != "playing" or duels[duel_id]["current_turn"] != player_id: return await callback.message.edit_text(f"{hbold('–û—à–∏–±–∫–∞!')}\n\n–°–µ–π—á–∞—Å –Ω–µ –≤–∞—à —Ö–æ–¥ –∏–ª–∏ –¥—É—ç–ª—å –∑–∞–≤–µ—Ä—à–µ–Ω–∞.", parse_mode="HTML")
        game, bet, first_player, second_player = duels[duel_id]["game"], duels[duel_id]["bet"], duels[duel_id]["first_player"], duels[duel_id]["second_player"]
        opponent_id = first_player if player_id == second_player else second_player
        emoji = {"dice": "üé≤", "basketball": "üèÄ", "bowling": "üé≥", "football": "‚öΩ", "darts": "üéØ"}[game]
        dice = await bot.send_dice(callback.message.chat.id, emoji=emoji); await asyncio.sleep(4); value = dice.dice.value
        determine_win = {"dice": determine_dice_win, "basketball": determine_basketball_win, "bowling": determine_bowling_win, "football": determine_football_win, "darts": determine_darts_win}[game]
        winnings, result_message = determine_win(value, bet)
        game_names = {"dice": "–ö—É–±–∏–∫–∏ üé≤", "basketball": "–ë–∞—Å–∫–µ—Ç–±–æ–ª üèÄ", "bowling": "–ë–æ—É–ª–∏–Ω–≥ üé≥", "football": "–§—É—Ç–±–æ–ª ‚öΩ", "darts": "–î–∞—Ä—Ç—Å üéØ"}
        await bot.send_message(opponent_id, f"{hbold('–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫ —Å–¥–µ–ª–∞–ª —Ö–æ–¥!')}\n\n@{users[player_id]['username']} –≤—ã–±—Ä–æ—Å–∏–ª: {value}\n{result_message}" if game == "dice" else f"{hbold('–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫ —Å–¥–µ–ª–∞–ª —Ö–æ–¥!')}\n\n@{users[player_id]['username']} —Å–¥–µ–ª–∞–ª —Ö–æ–¥.\n{result_message}", parse_mode="HTML")
        if winnings > 0:
            users[player_id]["balance"] += bet * 2; save_data()
            await bot.send_message(player_id, f"{hbold('–ü–æ–±–µ–¥–∞!')}\n\n{result_message}\n–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ –¥—É—ç–ª—å –≤ {game_names[game]} –∏ –∑–∞–±—Ä–∞–ª–∏ {hbold(f'{bet * 2} üí∞')}\n–í–∞—à –±–∞–ª–∞–Ω—Å: {hbold(str(users[player_id]['balance']) + ' üí∞')}", parse_mode="HTML")
            await bot.send_message(opponent_id, f"{hbold('–ü–æ—Ä–∞–∂–µ–Ω–∏–µ!')}\n\n@{users[player_id]['username']} –≤—ã–∏–≥—Ä–∞–ª –¥—É—ç–ª—å –≤ {game_names[game]}!\n{result_message}\n–í—ã –ø–æ—Ç–µ—Ä—è–ª–∏ {hbold(f'{bet} üí∞')}\n–í–∞—à –±–∞–ª–∞–Ω—Å: {hbold(str(users[opponent_id]['balance']) + ' üí∞')}", parse_mode="HTML")
            del duels[duel_id]
        else:
            duels[duel_id]["current_turn"] = opponent_id
            await bot.send_message(player_id, f"{hbold('–•–æ–¥ –∑–∞–≤–µ—Ä—à—ë–Ω!')}\n\n{result_message}\n–•–æ–¥ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –∫ @{users[opponent_id]['username']}", parse_mode="HTML")
            await bot.send_message(opponent_id, f"{hbold('–í–∞—à —Ö–æ–¥!')}\n\n@{users[player_id]['username']} –ø—Ä–æ–º–∞—Ö–Ω—É–ª—Å—è –≤ {game_names[game]}!\n{result_message}", reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="–°–¥–µ–ª–∞—Ç—å —Ö–æ–¥", callback_data=f"duel_turn_{duel_id}_{opponent_id}")]]), parse_mode="HTML")

@dp.message()
async def handle_game(message: Message):
    if MAINTENANCE_MODE: return await message.reply(f"{hbold('–¢–ï–•–ù–ò–ß–ï–°–ö–ò–ï –†–ê–ë–û–¢–´')}\n\n–ë–æ—Ç –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.", parse_mode="HTML")
    global jackpot, casino_balance
    user_id = str(message.from_user.id)
    username = message.from_user.username or "NoUsername"
    text = message.text.strip()
    if user_id not in users:
        users[user_id] = {"balance": STARTING_BALANCE, "username": username, "freespins": 0, "multiplier": 1.0, "last_daily_bonus": 0.0, "subscribed": False, "invited_by": None, "hide_in_leaderboard": False}
        awaiting_nickname[user_id] = True
        return await message.reply(f"{hbold('–î–û–ë–†–û –ü–û–ñ–ê–õ–û–í–ê–¢–¨!')}\n\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ —Å–≤–æ–π –Ω–∏–∫–Ω–µ–π–º:", parse_mode="HTML")
    if user_id in awaiting_nickname: return
    if check_and_add_daily_bonus(user_id): await message.reply(f"{hbold('–ï–ñ–ï–î–ù–ï–í–ù–´–ô –ë–û–ù–£–°!')}\n\n–í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ {hbold('1000 üí∞')}\n–ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {hbold(str(users[user_id]['balance']) + ' üí∞')}", parse_mode="HTML")
    if text in ["10 üí∞", "100 üí∞", "1000 üí∞", "–û–ª–ª-–∏–Ω üí∞", "–°–≤–æ—è —Å—Ç–∞–≤–∫–∞"] or text.isdigit():
        if not check_spam(user_id): return await message.reply(f"{hbold('–°–õ–ò–®–ö–û–ú –ë–´–°–¢–†–û!')}\n\n–ü–æ–¥–æ–∂–¥–∏ {SPAM_COOLDOWN} —Å–µ–∫—É–Ω–¥—ã –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –¥–µ–π—Å—Ç–≤–∏–µ–º.", parse_mode="HTML")
    if text == "–ò–≥—Ä—ã üéÆ": return await message.reply(f"{hbold('–í–´–ë–ï–†–ò –ò–ì–†–£:')}\n", reply_markup=get_game_menu(), parse_mode="HTML")
    if text == "–ê–∫–∫–∞—É–Ω—Ç üë§": return await message.reply(f"{hbold('–ê–ö–ö–ê–£–ù–¢')}\n\n–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=get_account_menu(), parse_mode="HTML")
    if text == "–ú–Ω–æ–≥–æ–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ –∫–∞–∑–∏–Ω–æ üë•": return await message.reply(f"{hbold('–ú–ù–û–ì–û–ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–¨–°–ö–û–ï –ö–ê–ó–ò–ù–û')}\n\n–í—ã–±–µ—Ä–∏ —Ä–µ–∂–∏–º:", reply_markup=get_multiplayer_menu(), parse_mode="HTML")
    if text == "–î—É—ç–ª—å ‚öîÔ∏è": return await message.reply(f"{hbold('–î–£–≠–õ–¨')}\n\n–í—ã–±–µ—Ä–∏—Ç–µ –∏–≥—Ä—É –¥–ª—è –¥—É—ç–ª–∏:", reply_markup=get_duel_game_menu(), parse_mode="HTML")
    if text == "–ö–æ–º–Ω–∞—Ç—ã üè†": return await message.reply(f"{hbold('–ö–û–ú–ù–ê–¢–´')}\n\n–ü–æ–∫–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ üîß", parse_mode="HTML")
    if text == "–ù–∞–∑–∞–¥ –≤ –∫–∞–∑–∏–Ω–æ": current_game.pop(user_id, None); return await message.reply(f"{hbold('–í–´–ë–ï–†–ò –†–ê–ó–î–ï–õ:')}\n", reply_markup=get_casino_menu(), parse_mode="HTML")
    if text.isdigit() and user_id in current_game and current_game[user_id].get("mode") == "duel" and "game" in current_game[user_id]:
        bet = int(text)
        if bet <= 0: return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –°—Ç–∞–≤–∫–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ 0!", parse_mode="HTML")
        if users[user_id]["balance"] < bet: return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –Ω–∞ –±–∞–ª–∞–Ω—Å–µ!", parse_mode="HTML")
        current_game[user_id]["bet"] = bet
        return await message.reply(f"{hbold('–ü–†–ò–ì–õ–ê–°–ò –°–û–ü–ï–†–ù–ò–ö–ê')}\n\n–í–≤–µ–¥–∏—Ç–µ @username –∏–≥—Ä–æ–∫–∞:", parse_mode="HTML")
    if text.startswith("@") and user_id in current_game and current_game[user_id].get("mode") == "duel" and "bet" in current_game[user_id]:
        target_username = text.lstrip('@')
        target_user_id = next((uid for uid, data in users.items() if data["username"].lower() == target_username.lower()), None)
        if not target_user_id: return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å @{target_username} –Ω–µ –Ω–∞–π–¥–µ–Ω!", parse_mode="HTML")
        if target_user_id == user_id: return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –ù–µ–ª—å–∑—è –≤—ã–∑–≤–∞—Ç—å —Å–∞–º–æ–≥–æ —Å–µ–±—è –Ω–∞ –¥—É—ç–ª—å!", parse_mode="HTML")
        duel_id = f"{user_id}_{target_user_id}_{int(time.time())}"
        game_names = {"dice": "–ö—É–±–∏–∫–∏ üé≤", "basketball": "–ë–∞—Å–∫–µ—Ç–±–æ–ª üèÄ", "bowling": "–ë–æ—É–ª–∏–Ω–≥ üé≥", "football": "–§—É—Ç–±–æ–ª ‚öΩ", "darts": "–î–∞—Ä—Ç—Å üéØ"}
        duels[duel_id] = {"challenger": user_id, "opponent": target_user_id, "game": current_game[user_id]["game"], "bet": current_game[user_id]["bet"], "state": "pending", "timestamp": time.time()}
        current_game.pop(user_id)
        await message.reply(f"{hbold('–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ!')}\n\n–û–∂–∏–¥–∞–π—Ç–µ –æ—Ç–≤–µ—Ç–∞ –æ—Ç @{target_username}.", parse_mode="HTML")
        keyboard = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="–ü—Ä–∏–Ω—è—Ç—å", callback_data=f"duel_accept_{duel_id}"), InlineKeyboardButton(text="–û—Ç–∫–ª–æ–Ω–∏—Ç—å", callback_data=f"duel_decline_{duel_id}")]])
        await bot.send_message(target_user_id, f"{hbold('–í–∞—Å –≤—ã–∑–≤–∞–ª–∏ –Ω–∞ –¥—É—ç–ª—å!')}\n\n–ò–≥—Ä–æ–∫: @{users[user_id]['username']}\n–ò–≥—Ä–∞: {game_names[duels[duel_id]['game']]}\n–°—Ç–∞–≤–∫–∞: {duels[duel_id]['bet']} üí∞\n–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ 10 –º–∏–Ω—É—Ç.", reply_markup=keyboard, parse_mode="HTML")
        await asyncio.sleep(600)
        if duel_id in duels and duels[duel_id]["state"] == "pending":
            del duels[duel_id]
            await bot.send_message(user_id, f"{hbold('–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –∏—Å—Ç–µ–∫–ª–æ!')}\n\n@{target_username} –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª –Ω–∞ –≤–∞—à—É –¥—É—ç–ª—å.", parse_mode="HTML")
            await bot.send_message(target_user_id, f"{hbold('–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –∏—Å—Ç–µ–∫–ª–æ!')}\n\n–î—É—ç–ª—å —Å @{users[user_id]['username']} –±–æ–ª—å—à–µ –Ω–µ –∞–∫—Ç—É–∞–ª—å–Ω–∞.", parse_mode="HTML")
        return
    if text == "–ë–æ–Ω—É—Å—ã üéÅ": return await message.reply(f"{hbold('–ë–û–ù–£–°–´')}\n\n–í—ã–±–µ—Ä–∏ –±–æ–Ω—É—Å:", reply_markup=get_bonus_menu(), parse_mode="HTML")
    if text == "–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª (+500 üí∞)":
        if users[user_id]["subscribed"]: return await message.reply(f"{hbold('–í—ã —É–∂–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã!')}\n\n–ë–æ–Ω—É—Å –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É —É–∂–µ –ø–æ–ª—É—á–µ–Ω.", reply_markup=get_bonus_menu(), parse_mode="HTML")
        keyboard = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è", url=TELEGRAM_CHANNEL)], [InlineKeyboardButton(text="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data=f"check_sub_{user_id}")]])
        return await message.reply(f"{hbold('–ü–û–î–ü–ò–®–ò–°–¨ –ù–ê –ö–ê–ù–ê–õ')}\n\n–ü–µ—Ä–µ–π–¥–∏ –ø–æ —Å—Å—ã–ª–∫–µ –∏ –ø–æ–¥–ø–∏—à–∏—Å—å, –∑–∞—Ç–µ–º –Ω–∞–∂–º–∏ '–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É':", reply_markup=keyboard, parse_mode="HTML")
    if text == "–ü—Ä–∏–≥–ª–∞—Å–∏ –¥—Ä—É–≥–∞ üë§": return await message.reply(f"{hbold('–ü–†–ò–ì–õ–ê–°–ò –î–†–£–ì–ê')}\n\n–í–∞—à–∞ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞:\n{hunderline(get_referral_link(user_id))}\n\n–ü—Ä–∏–≥–ª–∞—à–∞–π—Ç–µ –¥—Ä—É–∑–µ–π –∏ –ø–æ–ª—É—á–∞–π—Ç–µ {hbold(f'{REFERRAL_BONUS} üí∞')} –∑–∞ –∫–∞–∂–¥–æ–≥–æ –Ω–æ–≤–æ–≥–æ –∏–≥—Ä–æ–∫–∞!", reply_markup=get_bonus_menu(), parse_mode="HTML")
    if text == "–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤ üèÜ":
        if not users: return await message.reply(f"{hbold('–¢–ê–ë–õ–ò–¶–ê –õ–ò–î–ï–†–û–í')}\n\n–ü–æ–∫–∞ –Ω–µ—Ç –∏–≥—Ä–æ–∫–æ–≤ üòî", parse_mode="HTML")
        leaderboard = sorted([(uid, data) for uid, data in users.items() if not data.get("hide_in_leaderboard", False)], key=lambda x: x[1]["balance"], reverse=True)[:5]
        response = f"{hbold('–¢–ê–ë–õ–ò–¶–ê –õ–ò–î–ï–†–û–í')}\n\n" + "".join(f"  {i}. {data.get('nickname', data['username'])} (@{data['username']}): {hbold(str(data['balance']) + ' üí∞')}\n" if user_id in ADMINS else f"  {i}. {data.get('nickname', data['username'])}: {hbold(str(data['balance']) + ' üí∞')}\n" for i, (uid, data) in enumerate(leaderboard, 1)) + f"\n{hunderline('–°–ß–Å–¢ –ö–ê–ó–ò–ù–û:')} {hbold(str(casino_balance) + ' üí∞')}"
        keyboard = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="–ü–æ–∫–∞–∑–∞—Ç—å –≤—Å—é —Ç–∞–±–ª–∏—Ü—É", callback_data="show_full_leaderboard")]])
        return await message.reply(response, reply_markup=keyboard, parse_mode="HTML")
    if text == "–¢—É—Ä–Ω–∏—Ä—ã üèÖ": return await message.reply(f"{hbold('–¢–£–†–ù–ò–†–´')}\n\n–ü–æ–∫–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ üîß", reply_markup=get_casino_menu(), parse_mode="HTML")
    if text == "–ù–∞–∑–∞–¥ –≤ –∞–∫–∫–∞—É–Ω—Ç": return await message.reply(f"{hbold('–ê–ö–ö–ê–£–ù–¢')}\n\n–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=get_account_menu(), parse_mode="HTML")
    if text == "–ü–µ—Ä–µ–¥–∞—Ç—å –¥–µ–Ω—å–≥–∏ üí∏": return await message.reply(f"{hbold('–ü–ï–†–ï–î–ê–¢–¨ –î–ï–ù–¨–ì–ò')}\n\n–í–≤–µ–¥–∏—Ç–µ @username –∏ —Å—É–º–º—É —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª (–Ω–∞–ø—Ä–∏–º–µ—Ä, @User 500):", parse_mode="HTML")
    if text.startswith("@") and len(text.split()) == 2 and text.split()[1].isdigit():
        sender_id, target_username, amount = user_id, text.split()[0].lstrip('@'), int(text.split()[1])
        if amount <= 0: return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π!", parse_mode="HTML")
        if users[sender_id]["balance"] < amount: return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –Ω–∞ –±–∞–ª–∞–Ω—Å–µ!", parse_mode="HTML")
        target_user_id = next((uid for uid, data in users.items() if data["username"].lower() == target_username.lower()), None)
        if not target_user_id: return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å @{target_username} –Ω–µ –Ω–∞–π–¥–µ–Ω!", parse_mode="HTML")
        if target_user_id == sender_id: return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –ù–µ–ª—å–∑—è –ø–µ—Ä–µ–≤–µ—Å—Ç–∏ –¥–µ–Ω—å–≥–∏ —Å–∞–º–æ–º—É —Å–µ–±–µ!", parse_mode="HTML")
        users[sender_id]["balance"] -= amount; users[target_user_id]["balance"] += amount; save_data()
        await message.reply(f"{hbold('–£—Å–ø–µ—Ö!')} –í—ã –ø–µ—Ä–µ–¥–∞–ª–∏ {hbold(f'{amount} üí∞')} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é @{target_username}\n–í–∞—à –±–∞–ª–∞–Ω—Å: {hbold(str(users[sender_id]['balance']) + ' üí∞')}", reply_markup=get_account_menu(), parse_mode="HTML")
        try: await bot.send_message(target_user_id, f"{hbold('–í–∞–º –ø–µ—Ä–µ–¥–∞–ª–∏ –¥–µ–Ω—å–≥–∏!')}\n\n–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å @{users[sender_id]['username']} –ø–µ—Ä–µ–≤—ë–ª –≤–∞–º {hbold(f'{amount} üí∞')}\n–í–∞—à –±–∞–ª–∞–Ω—Å: {hbold(str(users[target_user_id]['balance']) + ' üí∞')}", parse_mode="HTML")
        except Exception as e: print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è {target_user_id}: {e}")
        return
    if text == "–ò–º—è ‚úèÔ∏è": return await message.reply(f"{hbold('–£–ü–†–ê–í–õ–ï–ù–ò–ï –ò–ú–ï–ù–ï–ú')}\n\n–¢–µ–∫—É—â–∏–π –Ω–∏–∫–Ω–µ–π–º: {hbold(users[user_id]['nickname'])}\n–°–∫—Ä—ã—Ç –≤ —Ç–∞–±–ª–∏—Ü–µ –ª–∏–¥–µ—Ä–æ–≤: {hbold('–î–∞' if users[user_id]['hide_in_leaderboard'] else '–ù–µ—Ç')}", reply_markup=get_name_menu(), parse_mode="HTML")
    if text == "–°–º–µ–Ω–∏—Ç—å –Ω–∏–∫–Ω–µ–π–º": awaiting_nickname[user_id] = True; return await message.reply(f"{hbold('–°–ú–ï–ù–ê –ù–ò–ö–ù–ï–ô–ú–ê')}\n\n–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –Ω–∏–∫–Ω–µ–π–º:", parse_mode="HTML")
    if text == "–°–∫—Ä—ã—Ç—å/–ü–æ–∫–∞–∑–∞—Ç—å –≤ —Ç–∞–±–ª–∏—Ü–µ –ª–∏–¥–µ—Ä–æ–≤": users[user_id]["hide_in_leaderboard"] = not users[user_id]["hide_in_leaderboard"]; save_data(); return await message.reply(f"{hbold('–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã!')}\n\n–°–∫—Ä—ã—Ç –≤ —Ç–∞–±–ª–∏—Ü–µ –ª–∏–¥–µ—Ä–æ–≤: {hbold('–î–∞' if users[user_id]['hide_in_leaderboard'] else '–ù–µ—Ç')}", reply_markup=get_name_menu(), parse_mode="HTML")
    games = {"–°–ª–æ—Ç—ã üé∞": "slot", "–ö—É–±–∏–∫–∏ üé≤": "dice", "–ë–∞—Å–∫–µ—Ç–±–æ–ª üèÄ": "basketball", "–ë–æ—É–ª–∏–Ω–≥ üé≥": "bowling", "–§—É—Ç–±–æ–ª ‚öΩ": "football", "–î–∞—Ä—Ç—Å üéØ": "darts"}
    if text in games: current_game[user_id] = games[text]; return await message.reply("", reply_markup=get_bet_keyboard(), parse_mode="HTML")
    if text == "–ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é": current_game.pop(user_id, None); return await message.reply(f"{hbold('–í–´–ë–ï–†–ò –ò–ì–†–£:')}\n", reply_markup=get_game_menu(), parse_mode="HTML")
    if text == "–ë–∞–ª–∞–Ω—Å": return await message.reply(f"{hbold('–¢–í–û–ô –ë–ê–õ–ê–ù–°')}\n\n  {hbold(str(users[user_id]['balance']) + ' üí∞')}\n  {hitalic('–§—Ä–∏—Å–ø–∏–Ω—ã:')} {hbold(str(users[user_id]['freespins']))}", parse_mode="HTML")
    if text == "–ü—Ä–∞–≤–∏–ª–∞ üìú": return await send_rules(message)
    predefined_bets = ["10 üí∞", "100 üí∞", "1000 üí∞", "–û–ª–ª-–∏–Ω üí∞"]
    if text in predefined_bets:
        bet = users[user_id]["balance"] if text == "–û–ª–ª-–∏–Ω üí∞" else int(text.split()[0])
        if text == "–û–ª–ª-–∏–Ω üí∞" and bet == 0: return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –í–∞—à –±–∞–ª–∞–Ω—Å 0 üí∞, –Ω–µ—á–µ–≥–æ —Å—Ç–∞–≤–∏—Ç—å!", parse_mode="HTML")
    elif text == "–°–≤–æ—è —Å—Ç–∞–≤–∫–∞": return await message.reply(f"{hbold('–í–í–ï–î–ò –°–£–ú–ú–£ –°–¢–ê–í–ö–ò')} {hitalic('(—á–∏—Å–ª–æ):')}", parse_mode="HTML")
    elif text.isdigit():
        bet = int(text)
        if bet <= 0: return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –°—Ç–∞–≤–∫–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å {hunderline('–±–æ–ª—å—à–µ 0')}", parse_mode="HTML")
    else: return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –í—ã–±–µ—Ä–∏ –∏–≥—Ä—É –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –¥–ª—è —Å—Ç–∞–≤–∫–∏!", parse_mode="HTML")
    if user_id not in current_game: return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ –∏–≥—Ä—É!\n", reply_markup=get_game_menu(), parse_mode="HTML")
    if users[user_id]["freespins"] > 0: bet, users[user_id]["freespins"] = 0, users[user_id]["freespins"] - 1
    elif users[user_id]["balance"] < bet: return await message.reply(f"{hbold('–û—à–∏–±–∫–∞:')} –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ üí∞ –Ω–∞ –±–∞–ª–∞–Ω—Å–µ!", parse_mode="HTML")
    else: users[user_id]["balance"] -= bet; casino_balance += bet; jackpot += bet // 10
    save_data()
    emoji = {"slot": "üé∞", "dice": "üé≤", "basketball": "üèÄ", "bowling": "üé≥", "football": "‚öΩ", "darts": "üéØ"}[current_game[user_id]]
    data = await bot.send_dice(chat_id=message.chat.id, emoji=emoji); dice_value = data.dice.value
    delay = {"slot": 2, "dice": 4, "basketball": 4, "bowling": 4, "football": 4, "darts": 4}[current_game[user_id]]
    await asyncio.sleep(delay)
    if current_game[user_id] == "slot":
        winnings, result_message, action = determine_slot_win(dice_value, bet, user_id)
        response = f"{hbold('–†–ï–ó–£–õ–¨–¢–ê–¢ –°–ü–ò–ù–ê')}\n\n{result_message}\n\n"
        if winnings > 0: users[user_id]["balance"] += winnings; casino_balance -= winnings; response += f"{hunderline('–í—ã–∏–≥—Ä—ã—à:')} {hbold(str(winnings) + ' üí∞')}\n"
        else: response += f"–ü–æ—Ç–µ—Ä—è–Ω–æ: {bet} üí∞\n"
        response += f"\n{hitalic('–ë–∞–ª–∞–Ω—Å:')} {hbold(str(users[user_id]['balance']) + ' üí∞')}\n{hitalic('–§—Ä–∏—Å–ø–∏–Ω—ã:')} {hbold(str(users[user_id]['freespins']))}"
        save_data(); await message.reply(response, parse_mode="HTML")
        if action == "gamble": await offer_gamble(user_id, message.chat.id, winnings)
    else:
        winnings, result_message = {"dice": determine_dice_win, "basketball": determine_basketball_win, "bowling": determine_bowling_win, "football": determine_football_win, "darts": determine_darts_win}[current_game[user_id]](dice_value, bet)
        response = f"{hbold('–†–ï–ó–£–õ–¨–¢–ê–¢')}\n\n{result_message}\n\n"
        if winnings > 0: users[user_id]["balance"] += winnings; casino_balance -= winnings; response += f"{hunderline('–í—ã–∏–≥—Ä—ã—à:')} {hbold(str(winnings) + ' üí∞')}\n"
        else: response += f"–ü–æ—Ç–µ—Ä—è–Ω–æ: {bet} üí∞\n"
        response += f"\n{hitalic('–ë–∞–ª–∞–Ω—Å:')} {hbold(str(users[user_id]['balance']) + ' üí∞')}"
        save_data(); await message.reply(response, parse_mode="HTML")

# Flask –¥–ª—è Render
app = Flask(__name__)

@app.route('/')
def home():
    return "Bot is running!"

def run_flask():
    app.run(host='0.0.0.0', port=5000)

# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
async def main():
    load_data()
    threading.Thread(target=run_flask, daemon=True).start()
    await dp.start_polling(bot)

if __name__ == '__main__':
    asyncio.run(main())
